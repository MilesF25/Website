

---
title: Week One Summary
author: Miles Franck
date: 9/5/23
---

# Professional PrÃ©cis
Miles Franck


Hi welcome to my website. I will be updating it from time to time with details of my work.

## Software Engineering Book

### Week 3

#### Summary

The book is about the concept of software engineering and its broader scope. The book talks about not just coding but also the tools and processes used to develop and maintain code over time. It raises questions about how programmers can maintain code and good coding practice to ensure that the code is able to last a long time. The key idea is that software engineering is "programming integrated over time



#### Reflection and Action Items

I feel as software engineers we need to be mindful of how we decide to code our program. We need to think about the long term, our program is going to be used and maintained by people years after us. We must ensure that what we decide to do doesn't make life hard for the people after us. For example we should find a way to get the program to run on every OS.


#### FB1

his chapter talks about the importance of testing in software development, The purpose of testing code is to find bugs, enhance your code and to make sure your code is reliable. Even though testing your code is important, it does not mean your code will work as intended.

#### Reflection and Action Items

Learning about how to make sure our program works will be very helpful. As of now I don't know many ways to make sure my code works. All I know is that 
if I get the expected output then it must be correct.



### Week 4


#### FB2

This chapter talks about code coverage. Code coverage is measuring which parts of a program are actually executed during a test run. This is important because test your code will guarantee that your code works and seeing what happens during a test run can help you understand your code more and allows to make improvements.The book also talked about black box and white box testing. Black box fuzzing, also known as "blind fuzzing," is a testing technique where the tester has no knowledge of the internal structure or source code of the target software. Testers treat the software as a "black box" and focus solely on the inputs and outputs. Another way is called white box testing. White box fuzzing, also known as "smart fuzzing" or "code-aware fuzzing," involves testing a program with an understanding of its internal structure, such as the source code, algorithms, or data structures.


####  Reflection and Action

The book gave some libaries to use for covering code. I think that this will be a big help when we want to go over our code. I think
that using these to help test our code is a good idea, but we should also try to make our own, even though that would be more work I think
it would be cool if we made our own libary just for Chasten.



#### SE2

In SE2 it talks how software engineering is porgramming overtime. It uses Hyrum's law as a good explination of what this means. Hyrum's law says that
as software is used by more people, they will come to rely on its existing behavior, even if that behavior was not initially intended or documented. This law talks about the importance of maintaining backward compatibility and consistency in software interfaces, as changes can inadvertently disrupt users.
It also talks about how software engineering unlike solitary programming, thrives on collaborative efforts. Success in software engineering hinges on anticipating and adapting to changes, both during development and post-release. Striking a balance between resource allocation, whether time or cost, and anticipated software benefits is vital. Software engineering projects are engineered for lasting impact, designed to endure for years.


### Week 5


#### FB3

Fuzzing book 3 talks about Fuzzing. Fuzzing is a technique used to test your code. It is doen by making a function that can randomly generate a
ton of inputs to test your code. The point of this is to see how much your program can handle before it breaks. An example of a fuzzing function is 
this.

```python
def fuzzer(max_length: int = 100, char_start: int = 32, char_range: int = 32) -> str:
    """A string of up to `max_length` characters
       in the range [`char_start`, `char_start` + `char_range`)"""
    string_length = random.randrange(0, max_length + 1)
    out = ""
    for i in range(0, string_length):
        out += chr(random.randrange(char_start, char_start + char_range))
    return out
```
This program will retrun a random string with characters chosen from the specified range, and the length of the string will vary from 0 to max_length.

#### Reflection and Action items
This chapter provides a good way to test our program. I think this is especially with chasten because we will be working with xpath expressions.
It will be important to see what our program can and can't handle

#### SE3

SE3 talks about the importace of working with people. The book emphasiszes that programming is not just about coding but it's also about working together.
The book gives some examples of famous people like Bill Gates or Linus. They didn't develop all of Linux or Microsoft on their own, they might have started
but they didn't do everything, they had a team to help them. This leads into the next topic "It's all about the team". In this part it talks about the three
pillars of social interaction humility, respect, and trust.

#### SE3 Refelction

After reading SE3, it's clear that we should all be mindful of how we communicate, especially when discussing someone else's code. If we come across as too critical, it can discourage the original coder from participating and make others hesitant to share their work for fear of harsh feedback. To create a more welcoming environment, we should aim for open and constructive discussions that encourage everyone to actively engage and improve together as a team.


### Week 6


### SE4

SE4 talked about  how crucial it is to foster a culture of knowledge sharing within organizations. The article highlights  the need for psychological safety, respect, and inclusivity as the foundation of this culture. It also talks about the damaging effects of toxic behavior and encourages active efforts to combat it. The article highlights Google's leadership principles as a prime example of promoting expertise and kindness simultaneously. It also stresses the significance of using incentives and recognition systems to motivate knowledge sharing.



### Reflection and Action items

We need to make sure we create a safe space so people feel comfterable enough to share. We don't want to make a space where people are scared to share their ideas.


### FB4 Mutation

Fuzzing book 4 is similar to fuzzing book 3. In FB4 it talks about another way to test your test suiets. To do this you give your code mutations, or "artifical faults". The point of this to see if the test suite can detect the incorrect inputs. An example of using mutations to test your code is this program.

```python
>>> for mutant in MuFunctionAnalyzer(gcd, log=True):
>>>     with mutant:
>>>         assert gcd(1, 0) == 1, "Minimal"
>>>         assert gcd(0, 1) == 1, "Mirror"
>>> mutant.pm.score()
->  gcd_1
<-  gcd_1
Detected gcd_1 <class 'UnboundLocalError'> local variable 'c' referenced before assignment

->  gcd_2
<-  gcd_2
Detected gcd_2 <class 'AssertionError'> Mirror

->  gcd_3
<-  gcd_3

->  gcd_4
<-  gcd_4

->  gcd_5
<-  gcd_5

->  gcd_6
<-  gcd_6

->  gcd_7
<-  gcd_7
Detected gcd_7 <class 'AssertionError'> Minimal


0.42857142857142855
```

```python

>>> class TestGCD(unittest.TestCase):
>>>     def test_simple(self):
>>>         assert cfg.gcd(1, 0) == 1
>>> 
>>>     def test_mirror(self):
>>>         assert cfg.gcd(0, 1) == 1
>>> for mutant in MuProgramAnalyzer('gcd', gcd_src):
>>>     mutant[test_module].runTest('TestGCD')
>>> mutant.pm.score()
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)

1.0
```

Theses two progrmas can be used to test your test cases with mutation.
The first program takes your function and two if it's test cases. Then it does the mutation analysis on it. The second program is used to evaluate the mutation score, that means it checks to see the number of failures with the code.


### Reflection and Action items

Testing your code is very important but only testing it one way is bad practice, making sure you account for every possiblity is important. After reading FB4 I think we should talk as a team and discuss all the posibilites that can happen when someone is using our program.

## Week 7


## FB5

MutationFuzzer class that takes a list of seed inputs which are then mutated.
FB5 is about mutation fuzzing. To make it simple, mutation fuzzing is similar to normal fuzzing, you're inserting a random character, deleting a character, or flipping a bit in a character representation but this time instead of just using random inputs with very little chance of being correct, you make some changes to the inputs so it can be valid. An example of this is 

```python
def delete_random_character(s: str) -> str:
    """Returns s with a random character deleted"""
    if s == "":
        return s

    pos = random.randint(0, len(s) - 1)
    # print("Deleting", repr(s[pos]), "at", pos)
    return s[:pos] + s[pos + 1:]

    seed_input = "A quick brown fox"
    for i in range(10):
        x = delete_random_character(seed_input)
        print(repr(x))
```
The output of this code is
'A uick brown fox'
'A quic brown fox'
'A quick brown fo'
'A quic brown fox'
'A quick bown fox'
'A quick bown fox'
'A quick brown fx'
'A quick brown ox'
'A quick brow fox'
'A quic brown fox'

As you can see the results are close but they are not correct.

### Reflection and Action items

Testing inputs that are can be considerd valid but not correct is important becuase we can make test cases for inputs that will likely never happen, but testing for inputs that can produce a output but produce the wrong output is very important. We should use the examples in this chapter to help us make test cases.

## SE5

### Summary

The text talks about the contrast between programming and software engineering, emphasizing the responsibilities of engineers in designing products for a diverse user base. It uses Google's own failures as an example in representing underrepresented groups and points out the importance of diversity in technology companies. SE5 discusses various examples where technology failed to account for diverse users, highlighting the unintended consequences of biased data and decision-making. The text calls for the industry to prioritize equity, challenge established processes, and engage users from diverse backgrounds to build more inclusive products.


### Reflection and Action Items

SE5 serves as a reminder that, as technology becomes increasingly central to our lives, the impact of software engineering extends to all corners of society. Recognizing and addressing bias is the cornerstone of equitable engineering. Reflecting on the text, it's clear that we must be mindful of our actions when designing programs.


## Week 8

## FB6

FB6 is about fuzzing with grammars. To summarize FB6 grammars are extra hints you can give to your fuzzing samples. By giving your inputs more correct information you will have a higher chance of generating usalbe inputs to your program.

This is an example of grammars

```python
>>> US_PHONE_GRAMMAR: Grammar = {
>>>     "<start>": ["<phone-number>"],
>>>     "<phone-number>": ["(<area>)<exchange>-<line>"],
>>>     "<area>": ["<lead-digit><digit><digit>"],
>>>     "<exchange>": ["<lead-digit><digit><digit>"],
>>>     "<line>": ["<digit><digit><digit><digit>"],
>>>     "<lead-digit>": ["2", "3", "4", "5", "6", "7", "8", "9"],
>>>     "<digit>": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
>>> }
>>> 
>>> assert is_valid_grammar(US_PHONE_GRAMMAR)
```
Here you can see that we have give the program so valid inputs to use when fuzzing. Now that we can get it to generate valid inputs it can be more helpful with testing our program. 

## Reflection and Action Items

Using grammars like the US_PHONE_GRAMMAR example in our program can help us thoroughly test our software with various valid inputs. This approach ensures that our software handles expected inputs correctly and guards against unexpected variations in input formats.




## SE6

### Summary


SE6 emphasizes the importance of effective leadership and management, offering valuable insights for leaders. It highlights the significance of setting clear goals, honest communication, and tracking team happiness. It also talks about strategies for motivating and providing direction to team members, it makes a connection between team members and plants, where each has unique needs. The conclusion underscores the role of humility, trust, and respect as essential pillars of good leadership.




### Action Items and Reflection

Effective leadership means leading, not just managing. Delegate, communicate clearly, and provide honest feedback. Ensure fair work distribution, promote skill development, and consider work-life balance. Use intrinsic motivation principles: give autonomy, skill opportunities, and a sense of purpose. Tailor your approach to individual team members, like caring for different plants. Prioritize honesty and trust-building. Leadership requires technical and social skills, including humility and respect.


## Week 9


### FB7

An efficent fuzzing grammar is a more efficent way to fuzz compared to normal fuzzing. Normal fuzzing is just generating a bunch of possibly correct
inputs and seeing if it works or not. A efficient grammar fuzzur makes use of derivation trees. Derivation trees is an interesting solution for the problem with regular fuzzing. By using a derivation tree, it allows us to not only generate inputs systematically but also gain more control over the testing process. We can always keep track of our expansion status, understand which elements have been expanded into which others, and identify which symbols still need to be expanded. Also the use of derivation trees offers the benefit of memory and time efficiency. Rather than repeatedly generating new inputs, we add new elements to the tree, which is a more efficient approach. This controlled and efficient method of input generation leads to more effective testing and a higher likelihood of discovering vulnerabilities and bugs in software.

### Reflection and Action Items

I think that it goes without saying having a more efficient way to fuzz our code is a good thing. It is a good idea to have a way to give our program
decent inputs to test instead of throwing random inputs at it. That being said I don't think chasten needs this kind of testing. I feel like our program
isn't so complex that it needs something like this to test it. I think that this could be an interesting conversation to have with the team.





