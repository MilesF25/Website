

---
title: Week One Summary
author: Miles Franck
date: 9/5/23
---

# Professional PrÃ©cis
Miles Franck


Hi welcome to my website. I will be updating it from time to time with details of my work.

## Software Engineering Book

### Week 1

#### Summary

The book is about the concept of software engineering and its broader scope. The book talks about not just coding but also the tools and processes used to develop and maintain code over time. It raises questions about how programmers can maintain code and good coding practice to ensure that the code is able to last a long time. The key idea is that software engineering is "programming integrated over time



#### Reflection and Action Items

I feel as software engineers we need to be mindful of how we decide to code our program. We need to think about the long term, our program is going to be used and maintained by people years after us. We must ensure that what we decide to do doesn't make life hard for the people after us. For example we should find a way to get the program to run on every OS.


#### FB1

his chapter talks about the importance of testing in software development, The purpose of testing code is to find bugs, enhance your code and to make sure your code is reliable. Even though testing your code is important, it does not mean your code will work as intended.

#### Reflection and Action Items

Learning about how to make sure our program works will be very helpful. As of now I don't know many ways to make sure my code works. All I know is that 
if I get the expected output then it must be correct.



### Week 2


#### FB2

This chapter talks about code coverage. Code coverage is measuring which parts of a program are actually executed during a test run. This is important because test your code will guarantee that your code works and seeing what happens during a test run can help you understand your code more and allows to make improvements.The book also talked about black box and white box testing. Black box fuzzing, also known as "blind fuzzing," is a testing technique where the tester has no knowledge of the internal structure or source code of the target software. Testers treat the software as a "black box" and focus solely on the inputs and outputs. Another way is called white box testing. White box fuzzing, also known as "smart fuzzing" or "code-aware fuzzing," involves testing a program with an understanding of its internal structure, such as the source code, algorithms, or data structures.


####  Reflection and Action

The book gave some libaries to use for covering code. I think that this will be a big help when we want to go over our code. I think
that using these to help test our code is a good idea, but we should also try to make our own, even though that would be more work I think
it would be cool if we made our own libary just for Chasten.



#### SE2

In SE2 it talks how software engineering is porgramming overtime. It uses Hyrum's law as a good explination of what this means. Hyrum's law says that
as software is used by more people, they will come to rely on its existing behavior, even if that behavior was not initially intended or documented. This law talks about the importance of maintaining backward compatibility and consistency in software interfaces, as changes can inadvertently disrupt users.
It also talks about how software engineering unlike solitary programming, thrives on collaborative efforts. Success in software engineering hinges on anticipating and adapting to changes, both during development and post-release. Striking a balance between resource allocation, whether time or cost, and anticipated software benefits is vital. Software engineering projects are engineered for lasting impact, designed to endure for years.


### Week 3


#### FB3

Fuzzing book 3 talks about Fuzzing. Fuzzing is a technique used to test your code. It is doen by making a function that can randomly generate a
ton of inputs to test your code. The point of this is to see how much your program can handle before it breaks. An example of a fuzzing function is 
this.

```python
def fuzzer(max_length: int = 100, char_start: int = 32, char_range: int = 32) -> str:
    """A string of up to `max_length` characters
       in the range [`char_start`, `char_start` + `char_range`)"""
    string_length = random.randrange(0, max_length + 1)
    out = ""
    for i in range(0, string_length):
        out += chr(random.randrange(char_start, char_start + char_range))
    return out
```
This program will retrun a random string with characters chosen from the specified range, and the length of the string will vary from 0 to max_length.

#### Reflection and Action items
This chapter provides a good way to test our program. I think this is especially with chasten because we will be working with xpath expressions.
It will be important to see what our program can and can't handle

#### SE3

SE3 talks about the importace of working with people. The book emphasiszes that programming is not just about coding but it's also about working together.
The book gives some examples of famous people like Bill Gates or Linus. They didn't develop all of Linux or Microsoft on their own, they might have started
but they didn't do everything, they had a team to help them. This leads into the next topic "It's all about the team". In this part it talks about the three
pillars of social interaction humility, respect, and trust.

#### SE3 Refelction

After reading SE3, it's clear that we should all be mindful of how we communicate, especially when discussing someone else's code. If we come across as too critical, it can discourage the original coder from participating and make others hesitant to share their work for fear of harsh feedback. To create a more welcoming environment, we should aim for open and constructive discussions that encourage everyone to actively engage and improve together as a team.


### Week 4


### SE4

SE4 talked about  how crucial it is to foster a culture of knowledge sharing within organizations. The article highlights  the need for psychological safety, respect, and inclusivity as the foundation of this culture. It also talks about the damaging effects of toxic behavior and encourages active efforts to combat it. The article highlights Google's leadership principles as a prime example of promoting expertise and kindness simultaneously. It also stresses the significance of using incentives and recognition systems to motivate knowledge sharing.



### Reflection and Action items

We need to make sure we create a safe space so people feel comfterable enough to share. We don't want to make a space where people are scared to share their ideas.


### FB4 Mutation

Fuzzing book 4 is similar to fuzzing book 3. In FB4 it talks about another way to test your test suiets. To do this you give your code mutations, or "artifical faults". The point of this to see if the test suite can detect the incorrect inputs. An example of using mutations to test your code is this program.

```python
>>> for mutant in MuFunctionAnalyzer(gcd, log=True):
>>>     with mutant:
>>>         assert gcd(1, 0) == 1, "Minimal"
>>>         assert gcd(0, 1) == 1, "Mirror"
>>> mutant.pm.score()
->  gcd_1
<-  gcd_1
Detected gcd_1 <class 'UnboundLocalError'> local variable 'c' referenced before assignment

->  gcd_2
<-  gcd_2
Detected gcd_2 <class 'AssertionError'> Mirror

->  gcd_3
<-  gcd_3

->  gcd_4
<-  gcd_4

->  gcd_5
<-  gcd_5

->  gcd_6
<-  gcd_6

->  gcd_7
<-  gcd_7
Detected gcd_7 <class 'AssertionError'> Minimal


0.42857142857142855
```

```python

>>> class TestGCD(unittest.TestCase):
>>>     def test_simple(self):
>>>         assert cfg.gcd(1, 0) == 1
>>> 
>>>     def test_mirror(self):
>>>         assert cfg.gcd(0, 1) == 1
>>> for mutant in MuProgramAnalyzer('gcd', gcd_src):
>>>     mutant[test_module].runTest('TestGCD')
>>> mutant.pm.score()
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
======================================================================
FAIL: test_simple (__main__.TestGCD)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_78662/2565918356.py", line 3, in test_simple
    assert cfg.gcd(1, 0) == 1
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)

1.0
```

Theses two progrmas can be used to test your test cases with mutation.
The first program takes your function and two if it's test cases. Then it does the mutation analysis on it. The second program is used to evaluate the mutation score, that means it checks to see the number of failures with the code.


### Reflection and Action items

Testing your code is very important but only testing it one way is bad practice, making sure you account for every possiblity is important. After reading FB4 I think we should talk as a team and discuss all the posibilites that can happen when someone is using our program.



## SE5

### Summary

The text talks about the contrast between programming and software engineering, emphasizing the responsibilities of engineers in designing products for a diverse user base. It uses Google's own failures as an example in representing underrepresented groups and points out the importance of diversity in technology companies. SE5 discusses various examples where technology failed to account for diverse users, highlighting the unintended consequences of biased data and decision-making. The text calls for the industry to prioritize equity, challenge established processes, and engage users from diverse backgrounds to build more inclusive products.


### Reflection and Action Items

SE5 serves as a reminder that, as technology becomes increasingly central to our lives, the impact of software engineering extends to all corners of society. Recognizing and addressing bias is the cornerstone of equitable engineering. Reflecting on the text, it's clear that we must be mindful of our actions when designing programs.




